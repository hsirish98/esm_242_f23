---
title: "HW 1"
author: "ESM242"
output: 
  html_document:
    code_folding: hide
date: '2023-10-10'
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r}
library(tidyverse)
library(nloptr)
library(knitr)
```


## Question 1: Mining Reserve {.tabset}


Suppose you own a mine with initial reserves $R_0$=1. You wish to determine the extraction rates, qt, that will maximize the sum of the present value of net benefits (PVNB) over a 10-year horizon t=0,1,…,9.  The net benefits from extraction are given by $\pi_t=c_0q_t+c_1q_t^2$ where $c_0$=0.8 and $c_1$=-0.1.  The discount rate is 0.05 and we’ll assume (at first) that any reserves left over in period 10 have a value of zero (i.e., $\lambda_0=0$). Find the extraction rates that maximize PVNB.  You will want to constrain extraction $q_t$ to be less than $R_t$ and for remaining reserves $R_{10}$ to be nonnegative.  

### A. 

What is the maximum PVNB with the initial set of parameters?

<span style="color: blue;">**Answer**</span>


```{r}
q1_eq <- function(q, R_init, end_year, delta, c0, c1){
  
    R = vector(mode="numeric",length=0) ## make vector for reserves
    extraction = vector(mode="numeric",length=0) ## make vector for extraction rates (q)
    bens = vector(mode="numeric",length=0) ## make vector for benefits
    
    R[1] = R_init ## set initial reserve 
    extraction[1] = q ##extraction is just the rate we're trying to find every period
    bens[1] = c0*extraction[1] + c1*(extraction[1])^2 ## benefits are from the c0*q + c1*q^2
    
    for(i in 2:(end_year+1)){ ##for 2nd spot in vector to 10th (year 9)
      extraction[i] = q ## extraction is just the optimized q 
      R[i] = R[i-1] - extraction[i-1] # every year R is diminished by the amount extracted
      bens[i] = c0*extraction[i] + c1*extraction[i]^2 ## benefits are given from the equation
    }
    
    t=seq(from=0,end_year) ##set amount of periods to add for present value 
  
    pv=((1/(1+delta))^t)*bens ##present value discounted
  
    npv=sum(pv) ## sum up present values, discounted
    
    return(-npv)
}


##make constraint function

constraint_q1 <- function(q, R_init, end_year = 9, delta = 0.05, c0=0.8, c1=-0.1){
  extraction <- vector()
  const <- vector()
  R <- vector()
  
  R[1] = R_init
  extraction[1] = q
  
  for(i in 2:(end_year+1)){
    R[i] = R[i-1] - extraction[i-1]
    extraction[i] = q
    const[i] = extraction[i] - R[i]
  }
  return(const)
}

#Use these options with nloptr
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-15,maxeval=16000)


 out=nloptr(x0=rep(0.1,times=10),eval_f=q1_eq,
              lb=rep(0,times=10),
              ub=rep(1,times=10),
              opts = options, R_init = 1, end_year = 9, delta = 0.05, c0=0.8, c1=-0.1)


 print(-out$objective)
 print(out$solution)


```




### B.

How does the PVNB change when you assume that reserves left over in period 10 have a per unit value of $\lambda_{10}$=1.2? How do the optimal values of $q_t$ compare to those in part a? Explain.

<span style="color: blue;">**Answer**
</span>

```{r}

q1_eq <- function(q, R_init, end_year, delta, c0, c1, lambda){
  
    R = vector() ## make vector for reserves
    extraction = vector() ## make vector for extraction rates (q)
    bens = vector() ## make vector for benefits
    
    R[1] = R_init ## set initial reserve 
    extraction[1] = q ##extraction is just the rate we're trying to find every period
    bens[1] = c0*extraction[1] + c1*(extraction[1])^2 ## benefits are from the c0*q + c1*q^2
    
    for(i in 2:(end_year+1)){ ##for 2nd spot in vector to 10th (year 9)
      extraction[i] = q ## extraction is just the optimized q 
      R[i] = R[i-1] - extraction[i-1] # every year R is diminished by the amount extracted
      bens[i] = c0*extraction[i-1] + c1*extraction[i-1]^2 ## benefits are given from the equation
    }
    
    R_end = R[end_year+1] - extraction[end_year+1]
    
    t=seq(from=0,end_year) 
  
    pv=((1/(1+delta))^t)*bens ##present value discounted
  
    npv=sum(pv) + (R_end*lambda)*(1/1+delta)
    
    return(-npv)
}

# constraint <- function(){
#   state <- vector()
#   const <- vector()
#   state[1] = init_state
#   const[1] = choice[1] - state[1] 
#   
# }


#Use these options with nloptr
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-15,maxeval=16000)


 out=nloptr(x0=rep(0.1,10),eval_f=q1_eq,
              lb=rep(0,10),
              ub=rep(1,10),
              opts = options, R_init = 1, end_year = 9, delta = 0.05, c0=0.8, c1=-0.1, lambda = 1.2)


 print(-out$objective)
 print(out$solution)
 
```




### C.

What is the PVNB when $\lambda_{10}=1.4$ How do the optimal values of $q_t$ compare to those in part a? Explain.

<span style="color: blue;">**Answer**
</span>



### D.

Even without using R, you could reason that the PVNB must be at least as large in parts b and c compared to part a. Explain.

<span style="color: blue;">**Answer**
</span>



### E.

Now set $\lambda_{10}$ back to 0 and set $c_1$=0. Resolve and explain what happens to the optimal values of $q_t$ compare to those in part a. 

<span style="color: blue;">**Answer**
</span>



